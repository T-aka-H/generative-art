<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <title>Gen-Art</title>
  <link rel="icon" href="favicon.ico">
  <link rel="apple-touch-icon" href="apple-touch-icon.png">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body {
      background: #000;
      color: #fff;
      width: 100%; height: 100%;
      font-family: Georgia, 'Times New Roman', serif;
      overflow-x: hidden;
    }
    body {
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
    }
    header {
      padding: 80px 0 60px;
      text-align: center;
    }
    header h1 {
      font-size: 14px;
      font-weight: 400;
      letter-spacing: 10px;
      text-transform: uppercase;
      color: rgba(255,255,255,0.35);
    }
    .gallery {
      display: flex;
      flex-direction: column;
      gap: 60px;
      padding: 0 24px 80px;
      max-width: 800px;
      width: 100%;
    }
    .work {
      display: block;
      text-decoration: none;
      color: inherit;
      position: relative;
      border: 1px solid rgba(255,255,255,0.08);
      transition: border-color 0.5s ease;
    }
    .work:hover {
      border-color: rgba(255,255,255,0.25);
    }
    .work-preview {
      width: 100%;
      aspect-ratio: 16 / 9;
      overflow: hidden;
      position: relative;
      background: #080808;
    }
    .work-preview canvas {
      width: 100%; height: 100%;
      display: block;
    }
    .work-info {
      padding: 24px 28px;
      display: flex;
      justify-content: space-between;
      align-items: baseline;
    }
    .work-title {
      font-size: 20px;
      letter-spacing: 8px;
      text-transform: uppercase;
      color: rgba(255,255,255,0.8);
      transition: color 0.3s;
    }
    .work:hover .work-title { color: #fff; }
    .work-sub {
      font-size: 12px;
      letter-spacing: 3px;
      color: rgba(255,255,255,0.25);
      font-family: -apple-system, sans-serif;
    }
    footer {
      padding: 40px 0;
      text-align: center;
      color: rgba(255,255,255,0.15);
      font-size: 11px;
      letter-spacing: 3px;
      font-family: -apple-system, sans-serif;
    }
    @media (max-width: 600px) {
      header { padding: 50px 0 40px; }
      header h1 { font-size: 12px; letter-spacing: 8px; }
      .gallery { gap: 40px; padding: 0 16px 60px; }
      .work-info { padding: 18px 20px; }
      .work-title { font-size: 16px; letter-spacing: 6px; }
      .work-sub { font-size: 10px; }
    }
  </style>
</head>
<body>
  <header>
    <h1>Gen-Art</h1>
  </header>
  <div class="gallery">
    <a href="./waves/" class="work">
      <div class="work-preview">
        <canvas id="cvWaves"></canvas>
      </div>
      <div class="work-info">
        <span class="work-title">Waves</span>
        <span class="work-sub">Interactive Ocean</span>
      </div>
    </a>
    <a href="./aurora/" class="work">
      <div class="work-preview">
        <canvas id="cvAurora"></canvas>
      </div>
      <div class="work-info">
        <span class="work-title">Aurora</span>
        <span class="work-sub">Mosaic of Light</span>
      </div>
    </a>
    <a href="./meadow/" class="work">
      <div class="work-preview">
        <canvas id="cvMeadow"></canvas>
      </div>
      <div class="work-info">
        <span class="work-title">Meadow</span>
        <span class="work-sub">Breeze and Light</span>
      </div>
    </a>
    <a href="./clouds/" class="work">
      <div class="work-preview">
        <canvas id="cvClouds"></canvas>
      </div>
      <div class="work-info">
        <span class="work-title">Clouds</span>
        <span class="work-sub">Drifting Forms</span>
      </div>
    </a>
    <a href="./snow/" class="work">
      <div class="work-preview">
        <canvas id="cvSnow"></canvas>
      </div>
      <div class="work-info">
        <span class="work-title">Snow</span>
        <span class="work-sub">Falling Light</span>
      </div>
    </a>
    <a href="./neon1/" class="work">
      <div class="work-preview">
        <canvas id="cvNeon"></canvas>
      </div>
      <div class="work-info">
        <span class="work-title">Neon1</span>
        <span class="work-sub">Skating Light</span>
      </div>
    </a>
    <a href="./neon2/" class="work">
      <div class="work-preview">
        <canvas id="cvNeon2"></canvas>
      </div>
      <div class="work-info">
        <span class="work-title">Neon2</span>
        <span class="work-sub">Triangle Light</span>
      </div>
    </a>
  </div>
  <footer>
    tap a work to enter<br>
    <a href="./about.html" style="color:rgba(255,255,255,0.12);text-decoration:none;font-size:10px;letter-spacing:2px;transition:color 0.3s" onmouseover="this.style.color='rgba(255,255,255,0.35)'" onmouseout="this.style.color='rgba(255,255,255,0.12)'">ABOUT</a>
  </footer>

  <script>
  // ミニプレビュー: 各作品の雰囲気をcanvasで描画
  (function() {
    // --- Waves プレビュー ---
    var cw = document.getElementById('cvWaves');
    var ctxW = cw.getContext('2d');
    var W = cw.width = 400;
    var H = cw.height = 225;
    var tW = 0;

    function drawWaves() {
      ctxW.fillStyle = 'rgba(0,0,15,0.15)';
      ctxW.fillRect(0, 0, W, H);
      for (var layer = 0; layer < 8; layer++) {
        var yBase = H * 0.3 + layer * (H * 0.08);
        var alpha = 0.12 + layer * 0.03;
        var hue = 200 + layer * 8 + Math.sin(tW * 0.3 + layer) * 15;
        ctxW.beginPath();
        ctxW.moveTo(0, H);
        for (var x = 0; x <= W; x += 4) {
          var y = yBase
            + Math.sin(x * 0.015 + tW * 0.5 + layer * 0.8) * 12
            + Math.sin(x * 0.008 + tW * 0.3 - layer * 0.5) * 8
            + Math.sin(x * 0.025 + tW * 0.7 + layer * 1.2) * 4;
          ctxW.lineTo(x, y);
        }
        ctxW.lineTo(W, H);
        ctxW.closePath();
        ctxW.fillStyle = 'hsla(' + hue + ',40%,' + (15 + layer * 4) + '%,' + alpha + ')';
        ctxW.fill();
      }
      tW += 0.02;
      requestAnimationFrame(drawWaves);
    }
    drawWaves();

    // --- Aurora プレビュー ---
    var ca = document.getElementById('cvAurora');
    var ctxA = ca.getContext('2d');
    var AW = ca.width = 400;
    var AH = ca.height = 225;
    var tA = 0;
    var dotA = 4;
    var colsA = Math.ceil(AW / dotA);
    var rowsA = Math.ceil(AH / dotA);

    // Smooth value noise with interpolation
    function hash2(ix, iy) {
      var n = Math.sin(ix * 127.1 + iy * 311.7) * 43758.5453;
      return n - Math.floor(n);
    }
    function vnoise(x, y) {
      var ix = Math.floor(x), iy = Math.floor(y);
      var fx = x - ix, fy = y - iy;
      fx = fx * fx * (3 - 2 * fx);
      fy = fy * fy * (3 - 2 * fy);
      var a = hash2(ix, iy), b = hash2(ix+1, iy);
      var c = hash2(ix, iy+1), d = hash2(ix+1, iy+1);
      return a + (b-a)*fx + (c-a)*fy + (a-b-c+d)*fx*fy;
    }
    function vnoise3(x, y, z) {
      var iz = Math.floor(z), fz = z - iz;
      fz = fz * fz * (3 - 2 * fz);
      return vnoise(x + iz * 17.3, y + iz * 31.7) * (1 - fz)
           + vnoise(x + (iz+1) * 17.3, y + (iz+1) * 31.7) * fz;
    }

    var auroraHues = [240, 270, 310, 200, 160, 120, 280, 350];

    function drawAurora() {
      for (var r = 0; r < rowsA; r++) {
        for (var c = 0; c < colsA; c++) {
          var gx = c * dotA;
          var gy = r * dotA;
          // Domain warping
          var warpX = vnoise3(gx * 0.008, gy * 0.008, tA * 0.4) * 60 - 30;
          var warpY = vnoise3(gx * 0.008 + 5, gy * 0.008 + 5, tA * 0.4) * 60 - 30;
          var wx = gx + warpX;
          var wy = gy + warpY;
          // Palette selection with smooth interpolation
          var ciRaw = vnoise3(wx * 0.005, wy * 0.005, tA * 0.5) * 8;
          var ci0 = Math.floor(ciRaw) % 8;
          var ci1 = (ci0 + 1) % 8;
          var frac = ciRaw - Math.floor(ciRaw);
          var baseH = auroraHues[ci0] + (auroraHues[ci1] - auroraHues[ci0]) * frac;
          var hueShift = vnoise3(wx * 0.004 + 10, wy * 0.01 + 10, tA * 0.3) * 60 - 30;
          var h = ((baseH + hueShift) % 360 + 360) % 360;
          var briN = vnoise3(wx * 0.005 + 20, wy * 0.01 + 20, tA * 0.4);
          var s = 45 + briN * 30;
          var l = 12 + briN * 28;
          ctxA.fillStyle = 'hsl(' + h + ',' + s + '%,' + l + '%)';
          ctxA.fillRect(gx, gy, dotA, dotA);
        }
      }
      tA += 0.008;
      requestAnimationFrame(drawAurora);
    }
    drawAurora();

    // --- Meadow プレビュー（ピクセルバッファ方式）---
    var cm = document.getElementById('cvMeadow');
    var ctxM = cm.getContext('2d');
    var MW = cm.width = 400;
    var MH = cm.height = 225;
    var tM = 0;
    var dotM = 4;
    var colsM = Math.ceil(MW / dotM);
    var rowsM = Math.ceil(MH / dotM);

    var meadowHues = [128, 162, 110, 172, 120, 155, 105, 148];

    function drawMeadow() {
      for (var r = 0; r < rowsM; r++) {
        for (var c = 0; c < colsM; c++) {
          var gx = c * dotM;
          var gy = r * dotM;
          // ドメインワーピング
          var warpX = vnoise3(gx * 0.006, gy * 0.008, tM * 0.15) * 70 - 35;
          var warpY = vnoise3(gx * 0.006 + 5, gy * 0.008 + 5, tM * 0.15) * 70 - 35;
          var wx = gx + warpX;
          var wy = gy + warpY;
          // パレットから色選択
          var ciRaw = vnoise3(wx * 0.005, wy * 0.006, tM * 0.08) * 8;
          var ci0 = Math.floor(ciRaw) % 8;
          var ci1 = (ci0 + 1) % 8;
          var frac = ciRaw - Math.floor(ciRaw);
          var h = meadowHues[ci0] + (meadowHues[ci1] - meadowHues[ci0]) * frac;
          var hShift = vnoise3(wx * 0.004 + 10, wy * 0.01 + 10, tM * 0.1) * 30 - 15;
          h = ((h + hShift) % 360 + 360) % 360;
          var briN = vnoise3(wx * 0.005 + 20, wy * 0.01 + 20, tM * 0.06);
          var s = 45 + briN * 25;
          var l = 12 + briN * 28;
          ctxM.fillStyle = 'hsl(' + h + ',' + s + '%,' + l + '%)';
          ctxM.fillRect(gx, gy, dotM, dotM);
        }
      }
      tM += 0.008;
      requestAnimationFrame(drawMeadow);
    }
    drawMeadow();

    // --- Clouds プレビュー ---
    var cc = document.getElementById('cvClouds');
    var ctxC = cc.getContext('2d');
    var CW = cc.width = 400;
    var CH = cc.height = 225;
    var tC = 0;
    var dotC = 4;
    var colsC = Math.ceil(CW / dotC);
    var rowsC = Math.ceil(CH / dotC);

    var cloudHues = [210, 220, 200, 230, 190, 240, 35, 215];

    function drawClouds() {
      var clearB = 15;
      for (var r = 0; r < rowsC; r++) {
        for (var c = 0; c < colsC; c++) {
          var gx = c * dotC;
          var gy = r * dotC;
          // ドメインワーピング
          var warpX = vnoise3(gx * 0.006, gy * 0.006, tC * 0.3) * 80 - 40;
          var warpY = vnoise3(gx * 0.006 + 5, gy * 0.006 + 5, tC * 0.3) * 80 - 40;
          var wx = gx + warpX;
          var wy = gy + warpY;

          // 密度フィールド（3層）
          var d1 = vnoise3(wx * 0.004, wy * 0.004, tC * 0.2);
          var d2 = vnoise3(wx * 0.012, wy * 0.012, tC * 0.4) * 0.5;
          var d3 = vnoise3(wx * 0.03, wy * 0.03, tC * 0.6) * 0.25;
          var raw = d1 + d2 + d3;

          // smoothstep
          var edge0 = 0.35, edge1 = 0.95;
          var st = (raw - edge0) / (edge1 - edge0);
          st = st < 0 ? 0 : (st > 1 ? 1 : st);
          var density = st * st * (3 - 2 * st);

          // パレットから色選択
          var ciRaw = vnoise3(wx * 0.005, wy * 0.005, tC * 0.5) * 8;
          var ci0 = Math.floor(ciRaw) % 8;
          var ci1 = (ci0 + 1) % 8;
          var frac = ciRaw - Math.floor(ciRaw);
          var h = cloudHues[ci0] + (cloudHues[ci1] - cloudHues[ci0]) * frac;
          var hShift = vnoise3(wx * 0.004 + 10, wy * 0.01 + 10, tC * 0.3) * 40 - 20;
          h = ((h + hShift) % 360 + 360) % 360;

          var s = 12 + vnoise3(wx * 0.005 + 20, wy * 0.01 + 20, tC * 0.4) * 18;
          var l = clearB + density * (55 - clearB);

          // 雲の芯は白っぽく
          if (density > 0.7) {
            var core = (density - 0.7) / 0.3;
            s *= (1 - core * 0.5);
            l += core * 10;
          }

          ctxC.fillStyle = 'hsl(' + h + ',' + s + '%,' + l + '%)';
          ctxC.fillRect(gx, gy, dotC, dotC);
        }
      }
      tC += 0.008;
      requestAnimationFrame(drawClouds);
    }
    drawClouds();

    // --- Snow プレビュー（パーティクルベース）---
    var cs = document.getElementById('cvSnow');
    var ctxS = cs.getContext('2d');
    var SW = cs.width = 400;
    var SH = cs.height = 225;
    var snowFlakes = [];
    for (var i = 0; i < 30; i++) {
      snowFlakes.push({
        x: Math.random() * SW,
        y: Math.random() * SH,
        size: 3 + Math.random() * 20,
        speed: 0.15 + Math.random() * 0.5,
        alpha: 0.05 + Math.random() * 0.2,
        drift: 0.3 + Math.random() * 0.8,
        phase: Math.random() * Math.PI * 2,
        driftSpd: 0.3 + Math.random() * 0.5
      });
    }
    var tS = 0;

    function drawSnow() {
      ctxS.fillStyle = 'rgba(0,2,10,0.12)';
      ctxS.fillRect(0, 0, SW, SH);
      for (var i = 0; i < snowFlakes.length; i++) {
        var f = snowFlakes[i];
        f.y += f.speed;
        f.x += Math.sin(tS * f.driftSpd + f.phase) * f.drift * 0.3;
        if (f.y > SH + f.size) { f.y = -f.size; f.x = Math.random() * SW; }
        if (f.x > SW + f.size) f.x = -f.size;
        if (f.x < -f.size) f.x = SW + f.size;
        var grad = ctxS.createRadialGradient(f.x, f.y, 0, f.x, f.y, f.size);
        grad.addColorStop(0, 'rgba(200,210,255,' + f.alpha + ')');
        grad.addColorStop(0.5, 'rgba(200,210,255,' + (f.alpha * 0.3) + ')');
        grad.addColorStop(1, 'rgba(200,210,255,0)');
        ctxS.fillStyle = grad;
        ctxS.beginPath();
        ctxS.arc(f.x, f.y, f.size, 0, Math.PI * 2);
        ctxS.fill();
      }
      tS += 0.02;
      requestAnimationFrame(drawSnow);
    }
    drawSnow();

    // --- Neon プレビュー（スケーター + 衝突で子が生まれる）---
    var cn = document.getElementById('cvNeon');
    var ctxN = cn.getContext('2d');
    var NW = cn.width = 400;
    var NH = cn.height = 225;
    var tN = 0;
    function pnoise(a, b) { return (Math.sin(a * 12.9898 + b * 78.233) * 43758.5453) % 1; }
    function snoise(seed, t) {
      var i = Math.floor(t), f = t - i;
      f = f * f * (3 - 2 * f);
      return pnoise(seed, i) * (1 - f) + pnoise(seed, i + 1) * f;
    }
    var nAll = [];
    var nPriCol = '255,20,100', nSecCol = '0,180,255', nChiCol = '255,245,200';
    var nCollCd = {};
    for (var ni = 0; ni < 6; ni++) {
      nAll.push({ x: NW * (0.15 + (ni % 3) * 0.3), y: NH * (0.2 + (ni % 2) * 0.6),
        px: 0, py: 0, angle: ni * 1.05, curv: 0, spd: 0.8 + ni * 0.08,
        seed: 42 + ni * 137, type: ni % 2 === 0 ? 'pri' : 'sec', cc: 0 });
      nAll[ni].px = nAll[ni].x; nAll[ni].py = nAll[ni].y;
    }
    function drawNeon() {
      ctxN.fillStyle = 'rgba(2,0,8,0.1)';
      ctxN.fillRect(0, 0, NW, NH);
      var pulse = 0.75 + Math.sin(tN * 0.5) * 0.25;
      ctxN.globalCompositeOperation = 'lighter';
      for (var si = 0; si < nAll.length; si++) {
        var s = nAll[si];
        s.px = s.x; s.py = s.y;
        var n1 = snoise(s.seed, tN * 0.06) - 0.5;
        var n2 = snoise(s.seed + 100, tN * 0.2) - 0.5;
        var tc = n1 * 0.06 + n2 * 0.025;
        var ln = snoise(s.seed + 200, tN * 0.1);
        if (ln > 0.75) tc += (ln - 0.75) * 4 * 0.12 * (n1 > 0 ? 1 : -1);
        s.curv += (tc - s.curv) * 0.03;
        s.angle += s.curv;
        s.x += Math.cos(s.angle) * s.spd;
        s.y += Math.sin(s.angle) * s.spd;
        var ex = Math.abs(s.x - NW / 2) / (NW / 2), ey = Math.abs(s.y - NH / 2) / (NH / 2);
        var edge = Math.max(ex, ey);
        if (edge > 0.8) {
          var da = Math.atan2(NH / 2 - s.y, NW / 2 - s.x) - s.angle;
          while (da > Math.PI) da -= Math.PI * 2;
          while (da < -Math.PI) da += Math.PI * 2;
          s.angle += da * (edge - 0.8) * 0.4;
        }
        var col = s.type === 'chi' ? nChiCol : (s.type === 'pri' ? nPriCol : nSecCol);
        var layers = [{ w: 8, a: 0.03 }, { w: 4, a: 0.08 }, { w: 1.5, a: 0.18 }, { w: 0.6, a: 0.3 }];
        ctxN.lineCap = 'round';
        for (var li = 0; li < layers.length; li++) {
          ctxN.strokeStyle = 'rgba(' + col + ',' + layers[li].a + ')';
          ctxN.lineWidth = layers[li].w;
          ctxN.beginPath(); ctxN.moveTo(s.px, s.py); ctxN.lineTo(s.x, s.y); ctxN.stroke();
        }
        var gs = [{ r: 8, a: 0.06 * pulse }, { r: 4, a: 0.15 * pulse }, { r: 1.8, a: 0.4 * pulse }];
        for (var gi = 0; gi < gs.length; gi++) {
          ctxN.fillStyle = 'rgba(' + col + ',' + gs[gi].a + ')';
          ctxN.beginPath(); ctxN.arc(s.x, s.y, gs[gi].r, 0, Math.PI * 2); ctxN.fill();
        }
        ctxN.fillStyle = 'rgba(255,240,255,' + (0.7 * pulse) + ')';
        ctxN.beginPath(); ctxN.arc(s.x, s.y, 0.8, 0, Math.PI * 2); ctxN.fill();
      }
      // Collision detection
      var nFrame = Math.floor(tN * 125);
      for (var i = 0; i < nAll.length; i++) {
        for (var j = i + 1; j < nAll.length; j++) {
          var dx = nAll[j].x - nAll[i].x, dy = nAll[j].y - nAll[i].y;
          var d = Math.sqrt(dx * dx + dy * dy);
          var ck = i * 100 + j;
          if (d < 15 && (!nCollCd[ck] || nFrame - nCollCd[ck] > 100)) {
            nCollCd[ck] = nFrame;
            nAll[i].angle = Math.atan2(-dy, -dx) + (Math.random() - 0.5) * 0.8;
            nAll[j].angle = Math.atan2(dy, dx) + (Math.random() - 0.5) * 0.8;
            // Primary + Secondary → spawn child
            var ts = [nAll[i].type, nAll[j].type].sort();
            if (ts[0] === 'pri' && ts[1] === 'sec' && nAll.length < 14) {
              nAll.push({ x: (nAll[i].x + nAll[j].x) / 2, y: (nAll[i].y + nAll[j].y) / 2,
                px: 0, py: 0, angle: Math.random() * Math.PI * 2, curv: 0,
                spd: 0.7 + Math.random() * 0.3, seed: 1000 + nAll.length * 137,
                type: 'chi', cc: 0 });
              var last = nAll[nAll.length - 1]; last.px = last.x; last.py = last.y;
            }
            // Child evolution
            if (nAll[i].type === 'chi') { nAll[i].cc++; if (nAll[i].cc >= 10) { nAll[i].type = Math.random() < 0.5 ? 'pri' : 'sec'; nAll[i].cc = 0; } }
            if (nAll[j].type === 'chi') { nAll[j].cc++; if (nAll[j].cc >= 10) { nAll[j].type = Math.random() < 0.5 ? 'pri' : 'sec'; nAll[j].cc = 0; } }
          }
        }
      }
      ctxN.globalCompositeOperation = 'source-over';
      tN += 0.008;
      requestAnimationFrame(drawNeon);
    }
    drawNeon();

    // --- Neon2 プレビュー（三角形軌道 + ランダムネオンカラー）---
    var cn2 = document.getElementById('cvNeon2');
    var ctxN2 = cn2.getContext('2d');
    var N2W = cn2.width = 400;
    var N2H = cn2.height = 225;
    var tN2 = 0;
    var TTP = 2.0943951; // 2*PI/3
    var TURN_SPD = 0.12;
    function triP(cx, cy, r, ang) {
      ctxN2.beginPath();
      ctxN2.moveTo(cx + r * Math.cos(ang), cy + r * Math.sin(ang));
      ctxN2.lineTo(cx + r * Math.cos(ang + TTP), cy + r * Math.sin(ang + TTP));
      ctxN2.lineTo(cx + r * Math.cos(ang - TTP), cy + r * Math.sin(ang - TTP));
      ctxN2.closePath();
    }
    function wakeP(tx, ty, hx, hy, hw, ang) {
      var pa = ang + Math.PI / 2;
      var cp2 = Math.cos(pa), sp2 = Math.sin(pa);
      ctxN2.beginPath();
      ctxN2.moveTo(tx, ty);
      ctxN2.lineTo(hx + hw * cp2, hy + hw * sp2);
      ctxN2.lineTo(hx - hw * cp2, hy - hw * sp2);
      ctxN2.closePath();
    }
    function rndNeon() {
      var h = Math.random() * 360, s = 0.8 + Math.random() * 0.2;
      var c = s, x = c * (1 - Math.abs((h / 60) % 2 - 1));
      var r1, g1, b1;
      if      (h < 60)  { r1=c; g1=x; b1=0; }
      else if (h < 120) { r1=x; g1=c; b1=0; }
      else if (h < 180) { r1=0; g1=c; b1=x; }
      else if (h < 240) { r1=0; g1=x; b1=c; }
      else if (h < 300) { r1=x; g1=0; b1=c; }
      else              { r1=c; g1=0; b1=x; }
      return Math.round((r1+(1-s))*255)+','+Math.round((g1+(1-s))*255)+','+Math.round((b1+(1-s))*255);
    }
    var n2All = [];
    var n2CollCd = {};
    for (var n2i = 0; n2i < 6; n2i++) {
      var sl = 30 + Math.random() * 40;
      n2All.push({ x: N2W * (0.15 + (n2i % 3) * 0.3), y: N2H * (0.2 + (n2i % 2) * 0.6),
        px: 0, py: 0, angle: n2i * 1.05, spd: 0.8 + n2i * 0.08, bspd: 0.8 + n2i * 0.08,
        seed: 42 + n2i * 137, col: rndNeon(),
        segDist: 0, segLen: sl, turnDir: Math.random() < 0.5 ? 1 : -1, turning: 0 });
      n2All[n2i].px = n2All[n2i].x; n2All[n2i].py = n2All[n2i].y;
    }
    function drawNeon2() {
      ctxN2.fillStyle = 'rgba(2,0,8,0.1)';
      ctxN2.fillRect(0, 0, N2W, N2H);
      var pulse2 = 0.75 + Math.sin(tN2 * 0.5) * 0.25;
      ctxN2.globalCompositeOperation = 'lighter';
      for (var si = 0; si < n2All.length; si++) {
        var s = n2All[si];
        s.px = s.x; s.py = s.y;
        // Wobble
        var wb = (snoise(s.seed, tN2 * 0.08) - 0.5) * 0.012;
        s.angle += wb;
        // Triangle trajectory
        if (s.turning > 0) {
          var step = Math.min(TURN_SPD, s.turning);
          s.angle += step * s.turnDir;
          s.turning -= step;
          s.spd += (s.bspd * 0.5 - s.spd) * 0.1;
        } else {
          s.segDist += s.spd;
          s.spd += (s.bspd - s.spd) * 0.05;
          if (s.segDist >= s.segLen) {
            s.segDist = 0;
            s.segLen = 30 + snoise(s.seed + 300, tN2 * 0.05) * 50;
            s.turning = TTP + (snoise(s.seed + 400, tN2 * 0.1) - 0.5) * 0.7;
            if (snoise(s.seed + 500, tN2 * 0.03) > 0.7) s.turnDir *= -1;
          }
        }
        s.x += Math.cos(s.angle) * s.spd;
        s.y += Math.sin(s.angle) * s.spd;
        // Edge steering
        var ex = Math.abs(s.x - N2W / 2) / (N2W / 2), ey = Math.abs(s.y - N2H / 2) / (N2H / 2);
        var edge = Math.max(ex, ey);
        if (edge > 0.8) {
          var da = Math.atan2(N2H / 2 - s.y, N2W / 2 - s.x) - s.angle;
          while (da > Math.PI) da -= Math.PI * 2;
          while (da < -Math.PI) da += Math.PI * 2;
          s.angle += da * (edge - 0.8) * 0.4;
          s.turning = 0; s.segDist = 0; s.segLen = 30 + Math.random() * 40;
        }
        // Wake triangle trail
        var tls = [{ hw: 4, a: 0.03 }, { hw: 2, a: 0.08 }, { hw: 0.8, a: 0.18 }];
        for (var li = 0; li < tls.length; li++) {
          ctxN2.fillStyle = 'rgba(' + s.col + ',' + tls[li].a + ')';
          wakeP(s.px, s.py, s.x, s.y, tls[li].hw, s.angle);
          ctxN2.fill();
        }
        // Triangle head glow
        var gs = [{ r: 8, a: 0.06 * pulse2 }, { r: 4, a: 0.15 * pulse2 }, { r: 1.8, a: 0.4 * pulse2 }];
        for (var gi = 0; gi < gs.length; gi++) {
          ctxN2.fillStyle = 'rgba(' + s.col + ',' + gs[gi].a + ')';
          triP(s.x, s.y, gs[gi].r, s.angle);
          ctxN2.fill();
        }
        ctxN2.fillStyle = 'rgba(255,240,255,' + (0.7 * pulse2) + ')';
        triP(s.x, s.y, 1.0, s.angle);
        ctxN2.fill();
      }
      // Collision + color change
      var nFrame2 = Math.floor(tN2 * 125);
      for (var i = 0; i < n2All.length; i++) {
        for (var j = i + 1; j < n2All.length; j++) {
          var dx = n2All[j].x - n2All[i].x, dy = n2All[j].y - n2All[i].y;
          var d = Math.sqrt(dx * dx + dy * dy);
          var ck = i * 100 + j;
          if (d < 15 && (!n2CollCd[ck] || nFrame2 - n2CollCd[ck] > 100)) {
            n2CollCd[ck] = nFrame2;
            n2All[i].angle = Math.atan2(-dy, -dx) + (Math.random() - 0.5) * 0.8;
            n2All[j].angle = Math.atan2(dy, dx) + (Math.random() - 0.5) * 0.8;
            n2All[i].col = rndNeon();
            n2All[j].col = rndNeon();
            n2All[i].turning = 0; n2All[i].segDist = 0;
            n2All[j].turning = 0; n2All[j].segDist = 0;
            if (n2All.length < 14) {
              n2All.push({ x: (n2All[i].x + n2All[j].x) / 2, y: (n2All[i].y + n2All[j].y) / 2,
                px: 0, py: 0, angle: Math.random() * Math.PI * 2,
                spd: 0.7 + Math.random() * 0.3, bspd: 0.7 + Math.random() * 0.3,
                seed: 2000 + n2All.length * 137, col: rndNeon(),
                segDist: 0, segLen: 30 + Math.random() * 40,
                turnDir: Math.random() < 0.5 ? 1 : -1, turning: 0 });
              var last = n2All[n2All.length - 1]; last.px = last.x; last.py = last.y;
            }
          }
        }
      }
      ctxN2.globalCompositeOperation = 'source-over';
      tN2 += 0.008;
      requestAnimationFrame(drawNeon2);
    }
    drawNeon2();
  })();
  </script>
</body>
</html>
