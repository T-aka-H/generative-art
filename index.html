<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta http-equiv="Cache-Control" content="no-cache, must-revalidate">
  <meta http-equiv="Pragma" content="no-cache">
  <title>Gen-Art</title>
  <link rel="icon" href="favicon.ico">
  <link rel="apple-touch-icon" href="apple-touch-icon.png">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body {
      background: #000;
      color: #fff;
      width: 100%; height: 100%;
      font-family: Georgia, 'Times New Roman', serif;
      overflow-x: hidden;
    }
    body {
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
    }
    header {
      padding: 80px 0 60px;
      text-align: center;
    }
    header h1 {
      font-size: 14px;
      font-weight: 400;
      letter-spacing: 10px;
      text-transform: uppercase;
      color: rgba(255,255,255,0.35);
    }
    .gallery {
      display: flex;
      flex-direction: column;
      gap: 60px;
      padding: 0 24px 80px;
      max-width: 800px;
      width: 100%;
    }
    .work {
      display: block;
      text-decoration: none;
      color: inherit;
      position: relative;
      border: 1px solid rgba(255,255,255,0.08);
      transition: border-color 0.5s ease;
    }
    .work:hover {
      border-color: rgba(255,255,255,0.25);
    }
    .work-preview {
      width: 100%;
      aspect-ratio: 16 / 9;
      overflow: hidden;
      position: relative;
      background: #080808;
    }
    .work-preview canvas {
      width: 100%; height: 100%;
      display: block;
    }
    .work-info {
      padding: 24px 28px;
      display: flex;
      justify-content: space-between;
      align-items: baseline;
    }
    .work-title {
      font-size: 20px;
      letter-spacing: 8px;
      text-transform: uppercase;
      color: rgba(255,255,255,0.8);
      transition: color 0.3s;
    }
    .work:hover .work-title { color: #fff; }
    .work-sub {
      font-size: 12px;
      letter-spacing: 3px;
      color: rgba(255,255,255,0.25);
      font-family: -apple-system, sans-serif;
    }
    footer {
      padding: 40px 0;
      text-align: center;
      color: rgba(255,255,255,0.15);
      font-size: 11px;
      letter-spacing: 3px;
      font-family: -apple-system, sans-serif;
    }
    @media (max-width: 600px) {
      header { padding: 50px 0 40px; }
      header h1 { font-size: 12px; letter-spacing: 8px; }
      .gallery { gap: 40px; padding: 0 16px 60px; }
      .work-info { padding: 18px 20px; }
      .work-title { font-size: 16px; letter-spacing: 6px; }
      .work-sub { font-size: 10px; }
    }
    /* Loading overlay — pure CSS, renders before JS */
    #loadingOverlay {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: #000;
      z-index: 9999;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      transition: opacity 0.8s ease;
    }
    #loadingOverlay.fade-out {
      opacity: 0;
      pointer-events: none;
    }
    .loading-title {
      font-size: 14px;
      font-weight: 400;
      letter-spacing: 10px;
      text-transform: uppercase;
      color: rgba(255,255,255,0.35);
      font-family: Georgia, 'Times New Roman', serif;
      animation: loadPulse 2s ease-in-out infinite;
    }
    .loading-line {
      width: 0;
      height: 1px;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.25), transparent);
      margin: 24px auto 0;
      animation: loadExpand 1.8s ease-out forwards;
    }
    .loading-dot {
      width: 4px; height: 4px;
      border-radius: 50%;
      background: rgba(255,255,255,0.15);
      margin: 16px auto 0;
      animation: loadDot 1.2s ease-in-out infinite;
    }
    @keyframes loadPulse {
      0%, 100% { opacity: 0.25; }
      50% { opacity: 0.6; }
    }
    @keyframes loadExpand {
      0% { width: 0; }
      100% { width: 100px; }
    }
    @keyframes loadDot {
      0%, 100% { opacity: 0.1; transform: scale(1); }
      50% { opacity: 0.4; transform: scale(1.5); }
    }
  </style>
</head>
<body>
  <div id="loadingOverlay">
    <div class="loading-title">Gen-Art</div>
    <div class="loading-line"></div>
    <div class="loading-dot"></div>
  </div>
  <header>
    <h1>Gen-Art</h1>
    <a href="./about.html" style="display:inline-block;margin-top:16px;color:rgba(255,255,255,0.18);text-decoration:none;font-size:10px;letter-spacing:3px;font-family:-apple-system,sans-serif;transition:color 0.3s" onmouseover="this.style.color='rgba(255,255,255,0.45)'" onmouseout="this.style.color='rgba(255,255,255,0.18)'">ABOUT</a>
  </header>
  <div class="gallery">
    <a href="./waves/index.html" class="work">
      <div class="work-preview">
        <canvas id="cvWaves"></canvas>
      </div>
      <div class="work-info">
        <span class="work-title">Waves</span>
        <span class="work-sub">Interactive Ocean</span>
      </div>
    </a>
    <a href="./aurora/index.html" class="work">
      <div class="work-preview">
        <canvas id="cvAurora"></canvas>
      </div>
      <div class="work-info">
        <span class="work-title">Aurora</span>
        <span class="work-sub">Mosaic of Light</span>
      </div>
    </a>
    <a href="./meadow/index.html" class="work">
      <div class="work-preview">
        <canvas id="cvMeadow"></canvas>
      </div>
      <div class="work-info">
        <span class="work-title">Meadow</span>
        <span class="work-sub">Breeze and Light</span>
      </div>
    </a>
    <a href="./clouds/index.html" class="work">
      <div class="work-preview">
        <canvas id="cvClouds"></canvas>
      </div>
      <div class="work-info">
        <span class="work-title">Clouds</span>
        <span class="work-sub">Drifting Forms</span>
      </div>
    </a>
    <a href="./snow/index.html" class="work">
      <div class="work-preview">
        <canvas id="cvSnow"></canvas>
      </div>
      <div class="work-info">
        <span class="work-title">Snow</span>
        <span class="work-sub">Falling Light</span>
      </div>
    </a>
    <a href="./neon1/index.html" class="work">
      <div class="work-preview">
        <canvas id="cvNeon"></canvas>
      </div>
      <div class="work-info">
        <span class="work-title">Neon1</span>
        <span class="work-sub">Skating Light</span>
      </div>
    </a>
    <a href="./neon2/index.html" class="work">
      <div class="work-preview">
        <canvas id="cvNeon2"></canvas>
      </div>
      <div class="work-info">
        <span class="work-title">Neon2</span>
        <span class="work-sub">Triangle Light</span>
      </div>
    </a>
    <a href="./neon3/index.html" class="work">
      <div class="work-preview">
        <canvas id="cvNeon3"></canvas>
      </div>
      <div class="work-info">
        <span class="work-title">Neon3</span>
        <span class="work-sub">Shape Shifting</span>
      </div>
    </a>
    <a href="./neon4/index.html" class="work">
      <div class="work-preview">
        <canvas id="cvNeon4"></canvas>
      </div>
      <div class="work-info">
        <span class="work-title">Neon4</span>
        <span class="work-sub">Grid Light</span>
      </div>
    </a>
    <a href="./neon5/index.html" class="work">
      <div class="work-preview">
        <canvas id="cvNeon5"></canvas>
      </div>
      <div class="work-info">
        <span class="work-title">Neon5</span>
        <span class="work-sub">Trig Waves</span>
      </div>
    </a>
    <a href="./neon6/index.html" class="work">
      <div class="work-preview">
        <canvas id="cvNeon6"></canvas>
      </div>
      <div class="work-info">
        <span class="work-title">Neon6</span>
        <span class="work-sub">Orbital</span>
      </div>
    </a>
  </div>
  <div style="text-align:center;padding:0 0 20px">
    <a href="./math.html" style="display:inline-block;color:rgba(255,255,255,0.18);text-decoration:none;font-size:10px;letter-spacing:3px;font-family:-apple-system,sans-serif;transition:color 0.3s" onmouseover="this.style.color='rgba(255,255,255,0.45)'" onmouseout="this.style.color='rgba(255,255,255,0.18)'">THE MATH BEHIND</a>
  </div>
  <footer>
    tap a work to enter
  </footer>

  <script>
  // Loading screen dismissal
  var _loadingDone = false;
  function dismissLoading() {
    if (_loadingDone) return;
    _loadingDone = true;
    var ov = document.getElementById('loadingOverlay');
    if (ov) {
      ov.classList.add('fade-out');
      setTimeout(function() { if (ov.parentNode) ov.parentNode.removeChild(ov); }, 900);
    }
  }
  // Fallback: dismiss after 1.2s even if observer hasn't fired
  setTimeout(dismissLoading, 1200);

  // Defer heavy canvas init to let loading screen paint first
  setTimeout(function() {
  // ミニプレビュー: IntersectionObserver で画面内のみアニメーション
  (function() {
    var visMap = {};
    var observer = new IntersectionObserver(function(entries) {
      entries.forEach(function(e) { visMap[e.target.id] = e.isIntersecting; });
      dismissLoading();
    }, { threshold: 0.1 });
    ['cvWaves','cvAurora','cvMeadow','cvClouds','cvSnow','cvNeon','cvNeon2','cvNeon3','cvNeon4','cvNeon5','cvNeon6'].forEach(function(id) {
      var el = document.getElementById(id);
      if (el) { observer.observe(el); visMap[id] = false; }
    });
    var frameSkip = 0;
    // --- Waves プレビュー ---
    var cw = document.getElementById('cvWaves');
    var ctxW = cw.getContext('2d');
    var W = cw.width = 400;
    var H = cw.height = 225;
    var tW = 0;

    function drawWaves() {
      requestAnimationFrame(drawWaves);
      if (!visMap['cvWaves']) return;
      ctxW.fillStyle = 'rgba(0,0,15,0.15)';
      ctxW.fillRect(0, 0, W, H);
      for (var layer = 0; layer < 8; layer++) {
        var yBase = H * 0.3 + layer * (H * 0.08);
        var alpha = 0.12 + layer * 0.03;
        var hue = 200 + layer * 8 + Math.sin(tW * 0.3 + layer) * 15;
        ctxW.beginPath();
        ctxW.moveTo(0, H);
        for (var x = 0; x <= W; x += 4) {
          var y = yBase
            + Math.sin(x * 0.015 + tW * 0.5 + layer * 0.8) * 12
            + Math.sin(x * 0.008 + tW * 0.3 - layer * 0.5) * 8
            + Math.sin(x * 0.025 + tW * 0.7 + layer * 1.2) * 4;
          ctxW.lineTo(x, y);
        }
        ctxW.lineTo(W, H);
        ctxW.closePath();
        ctxW.fillStyle = 'hsla(' + hue + ',40%,' + (15 + layer * 4) + '%,' + alpha + ')';
        ctxW.fill();
      }
      tW += 0.02;
    }
    drawWaves();

    // --- Aurora プレビュー ---
    var ca = document.getElementById('cvAurora');
    var ctxA = ca.getContext('2d');
    var AW = ca.width = 400;
    var AH = ca.height = 225;
    var tA = 0;
    var dotA = 4;
    var colsA = Math.ceil(AW / dotA);
    var rowsA = Math.ceil(AH / dotA);

    // Smooth value noise with interpolation
    function hash2(ix, iy) {
      var n = Math.sin(ix * 127.1 + iy * 311.7) * 43758.5453;
      return n - Math.floor(n);
    }
    function vnoise(x, y) {
      var ix = Math.floor(x), iy = Math.floor(y);
      var fx = x - ix, fy = y - iy;
      fx = fx * fx * (3 - 2 * fx);
      fy = fy * fy * (3 - 2 * fy);
      var a = hash2(ix, iy), b = hash2(ix+1, iy);
      var c = hash2(ix, iy+1), d = hash2(ix+1, iy+1);
      return a + (b-a)*fx + (c-a)*fy + (a-b-c+d)*fx*fy;
    }
    function vnoise3(x, y, z) {
      var iz = Math.floor(z), fz = z - iz;
      fz = fz * fz * (3 - 2 * fz);
      return vnoise(x + iz * 17.3, y + iz * 31.7) * (1 - fz)
           + vnoise(x + (iz+1) * 17.3, y + (iz+1) * 31.7) * fz;
    }

    var auroraHues = [240, 270, 310, 200, 160, 120, 280, 350];

    function drawAurora() {
      requestAnimationFrame(drawAurora);
      if (!visMap['cvAurora']) return;
      for (var r = 0; r < rowsA; r++) {
        for (var c = 0; c < colsA; c++) {
          var gx = c * dotA;
          var gy = r * dotA;
          // Domain warping
          var warpX = vnoise3(gx * 0.008, gy * 0.008, tA * 0.4) * 60 - 30;
          var warpY = vnoise3(gx * 0.008 + 5, gy * 0.008 + 5, tA * 0.4) * 60 - 30;
          var wx = gx + warpX;
          var wy = gy + warpY;
          // Palette selection with smooth interpolation
          var ciRaw = vnoise3(wx * 0.005, wy * 0.005, tA * 0.5) * 8;
          var ci0 = Math.floor(ciRaw) % 8;
          var ci1 = (ci0 + 1) % 8;
          var frac = ciRaw - Math.floor(ciRaw);
          var baseH = auroraHues[ci0] + (auroraHues[ci1] - auroraHues[ci0]) * frac;
          var hueShift = vnoise3(wx * 0.004 + 10, wy * 0.01 + 10, tA * 0.3) * 60 - 30;
          var h = ((baseH + hueShift) % 360 + 360) % 360;
          var briN = vnoise3(wx * 0.005 + 20, wy * 0.01 + 20, tA * 0.4);
          var s = 45 + briN * 30;
          var l = 12 + briN * 28;
          ctxA.fillStyle = 'hsl(' + h + ',' + s + '%,' + l + '%)';
          ctxA.fillRect(gx, gy, dotA, dotA);
        }
      }
      tA += 0.008;
    }
    drawAurora();

    // --- Meadow プレビュー（ピクセルバッファ方式）---
    var cm = document.getElementById('cvMeadow');
    var ctxM = cm.getContext('2d');
    var MW = cm.width = 400;
    var MH = cm.height = 225;
    var tM = 0;
    var dotM = 4;
    var colsM = Math.ceil(MW / dotM);
    var rowsM = Math.ceil(MH / dotM);

    var meadowHues = [128, 162, 110, 172, 120, 155, 105, 148];

    function drawMeadow() {
      requestAnimationFrame(drawMeadow);
      if (!visMap['cvMeadow']) return;
      for (var r = 0; r < rowsM; r++) {
        for (var c = 0; c < colsM; c++) {
          var gx = c * dotM;
          var gy = r * dotM;
          // ドメインワーピング
          var warpX = vnoise3(gx * 0.006, gy * 0.008, tM * 0.15) * 70 - 35;
          var warpY = vnoise3(gx * 0.006 + 5, gy * 0.008 + 5, tM * 0.15) * 70 - 35;
          var wx = gx + warpX;
          var wy = gy + warpY;
          // パレットから色選択
          var ciRaw = vnoise3(wx * 0.005, wy * 0.006, tM * 0.08) * 8;
          var ci0 = Math.floor(ciRaw) % 8;
          var ci1 = (ci0 + 1) % 8;
          var frac = ciRaw - Math.floor(ciRaw);
          var h = meadowHues[ci0] + (meadowHues[ci1] - meadowHues[ci0]) * frac;
          var hShift = vnoise3(wx * 0.004 + 10, wy * 0.01 + 10, tM * 0.1) * 30 - 15;
          h = ((h + hShift) % 360 + 360) % 360;
          var briN = vnoise3(wx * 0.005 + 20, wy * 0.01 + 20, tM * 0.06);
          var s = 45 + briN * 25;
          var l = 12 + briN * 28;
          ctxM.fillStyle = 'hsl(' + h + ',' + s + '%,' + l + '%)';
          ctxM.fillRect(gx, gy, dotM, dotM);
        }
      }
      tM += 0.008;
    }
    drawMeadow();

    // --- Clouds プレビュー ---
    var cc = document.getElementById('cvClouds');
    var ctxC = cc.getContext('2d');
    var CW = cc.width = 400;
    var CH = cc.height = 225;
    var tC = 0;
    var dotC = 4;
    var colsC = Math.ceil(CW / dotC);
    var rowsC = Math.ceil(CH / dotC);

    var cloudHues = [210, 220, 200, 230, 190, 240, 35, 215];

    function drawClouds() {
      requestAnimationFrame(drawClouds);
      if (!visMap['cvClouds']) return;
      var clearB = 15;
      for (var r = 0; r < rowsC; r++) {
        for (var c = 0; c < colsC; c++) {
          var gx = c * dotC;
          var gy = r * dotC;
          // ドメインワーピング
          var warpX = vnoise3(gx * 0.006, gy * 0.006, tC * 0.3) * 80 - 40;
          var warpY = vnoise3(gx * 0.006 + 5, gy * 0.006 + 5, tC * 0.3) * 80 - 40;
          var wx = gx + warpX;
          var wy = gy + warpY;

          // 密度フィールド（3層）
          var d1 = vnoise3(wx * 0.004, wy * 0.004, tC * 0.2);
          var d2 = vnoise3(wx * 0.012, wy * 0.012, tC * 0.4) * 0.5;
          var d3 = vnoise3(wx * 0.03, wy * 0.03, tC * 0.6) * 0.25;
          var raw = d1 + d2 + d3;

          // smoothstep
          var edge0 = 0.35, edge1 = 0.95;
          var st = (raw - edge0) / (edge1 - edge0);
          st = st < 0 ? 0 : (st > 1 ? 1 : st);
          var density = st * st * (3 - 2 * st);

          // パレットから色選択
          var ciRaw = vnoise3(wx * 0.005, wy * 0.005, tC * 0.5) * 8;
          var ci0 = Math.floor(ciRaw) % 8;
          var ci1 = (ci0 + 1) % 8;
          var frac = ciRaw - Math.floor(ciRaw);
          var h = cloudHues[ci0] + (cloudHues[ci1] - cloudHues[ci0]) * frac;
          var hShift = vnoise3(wx * 0.004 + 10, wy * 0.01 + 10, tC * 0.3) * 40 - 20;
          h = ((h + hShift) % 360 + 360) % 360;

          var s = 12 + vnoise3(wx * 0.005 + 20, wy * 0.01 + 20, tC * 0.4) * 18;
          var l = clearB + density * (55 - clearB);

          // 雲の芯は白っぽく
          if (density > 0.7) {
            var core = (density - 0.7) / 0.3;
            s *= (1 - core * 0.5);
            l += core * 10;
          }

          ctxC.fillStyle = 'hsl(' + h + ',' + s + '%,' + l + '%)';
          ctxC.fillRect(gx, gy, dotC, dotC);
        }
      }
      tC += 0.008;
    }
    drawClouds();

    // --- Snow プレビュー（パーティクルベース）---
    var cs = document.getElementById('cvSnow');
    var ctxS = cs.getContext('2d');
    var SW = cs.width = 400;
    var SH = cs.height = 225;
    var snowFlakes = [];
    for (var i = 0; i < 30; i++) {
      snowFlakes.push({
        x: Math.random() * SW,
        y: Math.random() * SH,
        size: 3 + Math.random() * 20,
        speed: 0.15 + Math.random() * 0.5,
        alpha: 0.05 + Math.random() * 0.2,
        drift: 0.3 + Math.random() * 0.8,
        phase: Math.random() * Math.PI * 2,
        driftSpd: 0.3 + Math.random() * 0.5
      });
    }
    var tS = 0;

    function drawSnow() {
      requestAnimationFrame(drawSnow);
      if (!visMap['cvSnow']) return;
      ctxS.fillStyle = 'rgba(0,2,10,0.12)';
      ctxS.fillRect(0, 0, SW, SH);
      for (var i = 0; i < snowFlakes.length; i++) {
        var f = snowFlakes[i];
        f.y += f.speed;
        f.x += Math.sin(tS * f.driftSpd + f.phase) * f.drift * 0.3;
        if (f.y > SH + f.size) { f.y = -f.size; f.x = Math.random() * SW; }
        if (f.x > SW + f.size) f.x = -f.size;
        if (f.x < -f.size) f.x = SW + f.size;
        var grad = ctxS.createRadialGradient(f.x, f.y, 0, f.x, f.y, f.size);
        grad.addColorStop(0, 'rgba(200,210,255,' + f.alpha + ')');
        grad.addColorStop(0.5, 'rgba(200,210,255,' + (f.alpha * 0.3) + ')');
        grad.addColorStop(1, 'rgba(200,210,255,0)');
        ctxS.fillStyle = grad;
        ctxS.beginPath();
        ctxS.arc(f.x, f.y, f.size, 0, Math.PI * 2);
        ctxS.fill();
      }
      tS += 0.02;
    }
    drawSnow();

    // --- Neon プレビュー（スケーター + 衝突で子が生まれる）---
    var cn = document.getElementById('cvNeon');
    var ctxN = cn.getContext('2d');
    var NW = cn.width = 400;
    var NH = cn.height = 225;
    var tN = 0;
    function pnoise(a, b) { return (Math.sin(a * 12.9898 + b * 78.233) * 43758.5453) % 1; }
    function snoise(seed, t) {
      var i = Math.floor(t), f = t - i;
      f = f * f * (3 - 2 * f);
      return pnoise(seed, i) * (1 - f) + pnoise(seed, i + 1) * f;
    }
    var nAll = [];
    var nPriCol = '255,20,100', nSecCol = '0,180,255', nChiCol = '255,245,200';
    var nCollCd = {};
    for (var ni = 0; ni < 6; ni++) {
      nAll.push({ x: NW * (0.15 + (ni % 3) * 0.3), y: NH * (0.2 + (ni % 2) * 0.6),
        px: 0, py: 0, angle: ni * 1.05, curv: 0, spd: 0.8 + ni * 0.08,
        seed: 42 + ni * 137, type: ni % 2 === 0 ? 'pri' : 'sec', cc: 0 });
      nAll[ni].px = nAll[ni].x; nAll[ni].py = nAll[ni].y;
    }
    function drawNeon() {
      requestAnimationFrame(drawNeon);
      if (!visMap['cvNeon']) return;
      ctxN.fillStyle = 'rgba(2,0,8,0.1)';
      ctxN.fillRect(0, 0, NW, NH);
      var pulse = 0.75 + Math.sin(tN * 0.5) * 0.25;
      ctxN.globalCompositeOperation = 'lighter';
      for (var si = 0; si < nAll.length; si++) {
        var s = nAll[si];
        s.px = s.x; s.py = s.y;
        var n1 = snoise(s.seed, tN * 0.06) - 0.5;
        var n2 = snoise(s.seed + 100, tN * 0.2) - 0.5;
        var tc = n1 * 0.06 + n2 * 0.025;
        var ln = snoise(s.seed + 200, tN * 0.1);
        if (ln > 0.75) tc += (ln - 0.75) * 4 * 0.12 * (n1 > 0 ? 1 : -1);
        s.curv += (tc - s.curv) * 0.03;
        s.angle += s.curv;
        s.x += Math.cos(s.angle) * s.spd;
        s.y += Math.sin(s.angle) * s.spd;
        var ex = Math.abs(s.x - NW / 2) / (NW / 2), ey = Math.abs(s.y - NH / 2) / (NH / 2);
        var edge = Math.max(ex, ey);
        if (edge > 0.8) {
          var da = Math.atan2(NH / 2 - s.y, NW / 2 - s.x) - s.angle;
          while (da > Math.PI) da -= Math.PI * 2;
          while (da < -Math.PI) da += Math.PI * 2;
          s.angle += da * (edge - 0.8) * 0.4;
        }
        var col = s.type === 'chi' ? nChiCol : (s.type === 'pri' ? nPriCol : nSecCol);
        var layers = [{ w: 8, a: 0.03 }, { w: 4, a: 0.08 }, { w: 1.5, a: 0.18 }, { w: 0.6, a: 0.3 }];
        ctxN.lineCap = 'round';
        for (var li = 0; li < layers.length; li++) {
          ctxN.strokeStyle = 'rgba(' + col + ',' + layers[li].a + ')';
          ctxN.lineWidth = layers[li].w;
          ctxN.beginPath(); ctxN.moveTo(s.px, s.py); ctxN.lineTo(s.x, s.y); ctxN.stroke();
        }
        var gs = [{ r: 8, a: 0.06 * pulse }, { r: 4, a: 0.15 * pulse }, { r: 1.8, a: 0.4 * pulse }];
        for (var gi = 0; gi < gs.length; gi++) {
          ctxN.fillStyle = 'rgba(' + col + ',' + gs[gi].a + ')';
          ctxN.beginPath(); ctxN.arc(s.x, s.y, gs[gi].r, 0, Math.PI * 2); ctxN.fill();
        }
        ctxN.fillStyle = 'rgba(255,240,255,' + (0.7 * pulse) + ')';
        ctxN.beginPath(); ctxN.arc(s.x, s.y, 0.8, 0, Math.PI * 2); ctxN.fill();
      }
      // Collision detection
      var nFrame = Math.floor(tN * 125);
      for (var i = 0; i < nAll.length; i++) {
        for (var j = i + 1; j < nAll.length; j++) {
          var dx = nAll[j].x - nAll[i].x, dy = nAll[j].y - nAll[i].y;
          var d = Math.sqrt(dx * dx + dy * dy);
          var ck = i * 100 + j;
          if (d < 15 && (!nCollCd[ck] || nFrame - nCollCd[ck] > 100)) {
            nCollCd[ck] = nFrame;
            nAll[i].angle = Math.atan2(-dy, -dx) + (Math.random() - 0.5) * 0.8;
            nAll[j].angle = Math.atan2(dy, dx) + (Math.random() - 0.5) * 0.8;
            // Primary + Secondary → spawn child
            var ts = [nAll[i].type, nAll[j].type].sort();
            if (ts[0] === 'pri' && ts[1] === 'sec' && nAll.length < 14) {
              nAll.push({ x: (nAll[i].x + nAll[j].x) / 2, y: (nAll[i].y + nAll[j].y) / 2,
                px: 0, py: 0, angle: Math.random() * Math.PI * 2, curv: 0,
                spd: 0.7 + Math.random() * 0.3, seed: 1000 + nAll.length * 137,
                type: 'chi', cc: 0 });
              var last = nAll[nAll.length - 1]; last.px = last.x; last.py = last.y;
            }
            // Child evolution
            if (nAll[i].type === 'chi') { nAll[i].cc++; if (nAll[i].cc >= 10) { nAll[i].type = Math.random() < 0.5 ? 'pri' : 'sec'; nAll[i].cc = 0; } }
            if (nAll[j].type === 'chi') { nAll[j].cc++; if (nAll[j].cc >= 10) { nAll[j].type = Math.random() < 0.5 ? 'pri' : 'sec'; nAll[j].cc = 0; } }
          }
        }
      }
      ctxN.globalCompositeOperation = 'source-over';
      tN += 0.008;
    }
    drawNeon();

    // --- Neon2 プレビュー（三角形軌道 + ランダムネオンカラー）---
    var cn2 = document.getElementById('cvNeon2');
    var ctxN2 = cn2.getContext('2d');
    var N2W = cn2.width = 400;
    var N2H = cn2.height = 225;
    var tN2 = 0;
    var TTP = 2.0943951; // 2*PI/3
    var TURN_SPD = 0.12;
    function triP(cx, cy, r, ang) {
      ctxN2.beginPath();
      ctxN2.moveTo(cx + r * Math.cos(ang), cy + r * Math.sin(ang));
      ctxN2.lineTo(cx + r * Math.cos(ang + TTP), cy + r * Math.sin(ang + TTP));
      ctxN2.lineTo(cx + r * Math.cos(ang - TTP), cy + r * Math.sin(ang - TTP));
      ctxN2.closePath();
    }
    function wakeP(tx, ty, hx, hy, hw, ang) {
      var pa = ang + Math.PI / 2;
      var cp2 = Math.cos(pa), sp2 = Math.sin(pa);
      ctxN2.beginPath();
      ctxN2.moveTo(tx, ty);
      ctxN2.lineTo(hx + hw * cp2, hy + hw * sp2);
      ctxN2.lineTo(hx - hw * cp2, hy - hw * sp2);
      ctxN2.closePath();
    }
    function rndNeon() {
      var h = Math.random() * 360, s = 0.8 + Math.random() * 0.2;
      var c = s, x = c * (1 - Math.abs((h / 60) % 2 - 1));
      var r1, g1, b1;
      if      (h < 60)  { r1=c; g1=x; b1=0; }
      else if (h < 120) { r1=x; g1=c; b1=0; }
      else if (h < 180) { r1=0; g1=c; b1=x; }
      else if (h < 240) { r1=0; g1=x; b1=c; }
      else if (h < 300) { r1=x; g1=0; b1=c; }
      else              { r1=c; g1=0; b1=x; }
      return Math.round((r1+(1-s))*255)+','+Math.round((g1+(1-s))*255)+','+Math.round((b1+(1-s))*255);
    }
    var n2All = [];
    var n2CollCd = {};
    for (var n2i = 0; n2i < 6; n2i++) {
      var sl = 30 + Math.random() * 40;
      n2All.push({ x: N2W * (0.15 + (n2i % 3) * 0.3), y: N2H * (0.2 + (n2i % 2) * 0.6),
        px: 0, py: 0, angle: n2i * 1.05, spd: 0.8 + n2i * 0.08, bspd: 0.8 + n2i * 0.08,
        seed: 42 + n2i * 137, col: rndNeon(),
        segDist: 0, segLen: sl, turnDir: Math.random() < 0.5 ? 1 : -1, turning: 0 });
      n2All[n2i].px = n2All[n2i].x; n2All[n2i].py = n2All[n2i].y;
    }
    function drawNeon2() {
      requestAnimationFrame(drawNeon2);
      if (!visMap['cvNeon2']) return;
      ctxN2.fillStyle = 'rgba(2,0,8,0.1)';
      ctxN2.fillRect(0, 0, N2W, N2H);
      var pulse2 = 0.75 + Math.sin(tN2 * 0.5) * 0.25;
      ctxN2.globalCompositeOperation = 'lighter';
      for (var si = 0; si < n2All.length; si++) {
        var s = n2All[si];
        s.px = s.x; s.py = s.y;
        // Wobble
        var wb = (snoise(s.seed, tN2 * 0.08) - 0.5) * 0.012;
        s.angle += wb;
        // Triangle trajectory
        if (s.turning > 0) {
          var step = Math.min(TURN_SPD, s.turning);
          s.angle += step * s.turnDir;
          s.turning -= step;
          s.spd += (s.bspd * 0.5 - s.spd) * 0.1;
        } else {
          s.segDist += s.spd;
          s.spd += (s.bspd - s.spd) * 0.05;
          if (s.segDist >= s.segLen) {
            s.segDist = 0;
            s.segLen = 30 + snoise(s.seed + 300, tN2 * 0.05) * 50;
            s.turning = TTP + (snoise(s.seed + 400, tN2 * 0.1) - 0.5) * 0.7;
            if (snoise(s.seed + 500, tN2 * 0.03) > 0.7) s.turnDir *= -1;
          }
        }
        s.x += Math.cos(s.angle) * s.spd;
        s.y += Math.sin(s.angle) * s.spd;
        // Edge steering
        var ex = Math.abs(s.x - N2W / 2) / (N2W / 2), ey = Math.abs(s.y - N2H / 2) / (N2H / 2);
        var edge = Math.max(ex, ey);
        if (edge > 0.8) {
          var da = Math.atan2(N2H / 2 - s.y, N2W / 2 - s.x) - s.angle;
          while (da > Math.PI) da -= Math.PI * 2;
          while (da < -Math.PI) da += Math.PI * 2;
          s.angle += da * (edge - 0.8) * 0.4;
          s.turning = 0; s.segDist = 0; s.segLen = 30 + Math.random() * 40;
        }
        // Wake triangle trail
        var tls = [{ hw: 4, a: 0.03 }, { hw: 2, a: 0.08 }, { hw: 0.8, a: 0.18 }];
        for (var li = 0; li < tls.length; li++) {
          ctxN2.fillStyle = 'rgba(' + s.col + ',' + tls[li].a + ')';
          wakeP(s.px, s.py, s.x, s.y, tls[li].hw, s.angle);
          ctxN2.fill();
        }
        // Triangle head glow
        var gs = [{ r: 8, a: 0.06 * pulse2 }, { r: 4, a: 0.15 * pulse2 }, { r: 1.8, a: 0.4 * pulse2 }];
        for (var gi = 0; gi < gs.length; gi++) {
          ctxN2.fillStyle = 'rgba(' + s.col + ',' + gs[gi].a + ')';
          triP(s.x, s.y, gs[gi].r, s.angle);
          ctxN2.fill();
        }
        ctxN2.fillStyle = 'rgba(255,240,255,' + (0.7 * pulse2) + ')';
        triP(s.x, s.y, 1.0, s.angle);
        ctxN2.fill();
      }
      // Collision + color change
      var nFrame2 = Math.floor(tN2 * 125);
      for (var i = 0; i < n2All.length; i++) {
        for (var j = i + 1; j < n2All.length; j++) {
          var dx = n2All[j].x - n2All[i].x, dy = n2All[j].y - n2All[i].y;
          var d = Math.sqrt(dx * dx + dy * dy);
          var ck = i * 100 + j;
          if (d < 15 && (!n2CollCd[ck] || nFrame2 - n2CollCd[ck] > 100)) {
            n2CollCd[ck] = nFrame2;
            n2All[i].angle = Math.atan2(-dy, -dx) + (Math.random() - 0.5) * 0.8;
            n2All[j].angle = Math.atan2(dy, dx) + (Math.random() - 0.5) * 0.8;
            n2All[i].col = rndNeon();
            n2All[j].col = rndNeon();
            n2All[i].turning = 0; n2All[i].segDist = 0;
            n2All[j].turning = 0; n2All[j].segDist = 0;
            if (n2All.length < 14) {
              n2All.push({ x: (n2All[i].x + n2All[j].x) / 2, y: (n2All[i].y + n2All[j].y) / 2,
                px: 0, py: 0, angle: Math.random() * Math.PI * 2,
                spd: 0.7 + Math.random() * 0.3, bspd: 0.7 + Math.random() * 0.3,
                seed: 2000 + n2All.length * 137, col: rndNeon(),
                segDist: 0, segLen: 30 + Math.random() * 40,
                turnDir: Math.random() < 0.5 ? 1 : -1, turning: 0 });
              var last = n2All[n2All.length - 1]; last.px = last.x; last.py = last.y;
            }
          }
        }
      }
      ctxN2.globalCompositeOperation = 'source-over';
      tN2 += 0.008;
    }
    drawNeon2();

    // --- Neon3 プレビュー（3スケーター + 図形軌道物理）---
    (function() {
    var cn3 = document.getElementById('cvNeon3');
    if (!cn3) return;
    var ctxN3 = cn3.getContext('2d');
    var N3W = cn3.width = 400, N3H = cn3.height = 225;
    var tN3 = 0;
    var TWO_THIRDS = 2.0943951;
    var N3_TURN_SPD = 0.12;
    var n3Colors = ['255,40,80', '20,100,255', '255,240,180'];
    var n3Shapes = ['circle', 'triangle', 'square'];
    var n3S = [];
    for (var i = 0; i < 3; i++) {
      n3S.push({ x: N3W * (0.2 + i * 0.3), y: N3H * 0.5, px: 0, py: 0,
        angle: i * 2.1, curv: 0, spd: 0.9, bspd: 0.9, seed: 42 + i * 95,
        col: n3Colors[i], shape: n3Shapes[i],
        segDist: 0, segLen: 30 + Math.random() * 40,
        turnDir: Math.random() < 0.5 ? 1 : -1, turning: 0 });
    }
    for (var i = 0; i < 3; i++) { n3S[i].px = n3S[i].x; n3S[i].py = n3S[i].y; }

    function n3Wake(tx, ty, hx, hy, hw, ang) {
      var pa = ang + Math.PI / 2;
      var cp = Math.cos(pa), sp = Math.sin(pa);
      ctxN3.beginPath();
      ctxN3.moveTo(tx, ty);
      ctxN3.lineTo(hx + hw * cp, hy + hw * sp);
      ctxN3.lineTo(hx - hw * cp, hy - hw * sp);
      ctxN3.closePath();
    }

    function n3DrawShape(ctx, shape, cx, cy, r, ang) {
      if (shape === 'circle') {
        ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI * 2);
      } else if (shape === 'triangle') {
        ctx.beginPath();
        ctx.moveTo(cx + r * Math.cos(ang), cy + r * Math.sin(ang));
        ctx.lineTo(cx + r * Math.cos(ang + TWO_THIRDS), cy + r * Math.sin(ang + TWO_THIRDS));
        ctx.lineTo(cx + r * Math.cos(ang - TWO_THIRDS), cy + r * Math.sin(ang - TWO_THIRDS));
        ctx.closePath();
      } else {
        var c = Math.cos(ang), s = Math.sin(ang), hr = r * 0.707;
        ctx.beginPath();
        ctx.moveTo(cx + hr * (c - s), cy + hr * (s + c));
        ctx.lineTo(cx + hr * (-c - s), cy + hr * (-s + c));
        ctx.lineTo(cx + hr * (-c + s), cy + hr * (-s - c));
        ctx.lineTo(cx + hr * (c + s), cy + hr * (s - c));
        ctx.closePath();
      }
    }

    function drawNeon3() {
      requestAnimationFrame(drawNeon3);
      if (!visMap['cvNeon3']) return;
      ctxN3.fillStyle = 'rgba(5,0,6,0.08)';
      ctxN3.fillRect(0, 0, N3W, N3H);
      var pulse3 = 0.75 + Math.sin(tN3 * 0.5) * 0.25;
      ctxN3.globalCompositeOperation = 'lighter';

      for (var si = 0; si < 3; si++) {
        var s = n3S[si];
        s.px = s.x; s.py = s.y;

        // Shape-dependent trajectory physics
        if (s.shape === 'circle') {
          // Circular loops with organic wobble (curvature ~0.03 + noise)
          var n1 = snoise(s.seed, tN3 * 0.04) - 0.5;
          var tc = 0.03 * s.turnDir + n1 * 0.02;
          s.curv += (tc - s.curv) * 0.04;
          s.angle += s.curv;
          // Drift shifts loop center across screen
          var drift = (snoise(s.seed + 99, tN3 * 0.008) - 0.5) * 0.012;
          s.angle += drift;
          s.spd += (s.bspd - s.spd) * 0.05;
          s.segDist += s.spd;
          if (s.segDist > 200 + snoise(s.seed + 600, tN3 * 0.05) * 150) {
            s.segDist = 0;
            if (Math.random() < 0.5) s.turnDir *= -1;
          }
        } else {
          // Triangle (120°) or Square (90°): straight + sharp turns
          var turnAngle = s.shape === 'triangle' ? TWO_THIRDS : Math.PI / 2;
          var wb = (snoise(s.seed, tN3 * 0.08) - 0.5) * 0.012;
          s.angle += wb;
          if (s.turning > 0) {
            var step = Math.min(N3_TURN_SPD, s.turning);
            s.angle += step * s.turnDir;
            s.turning -= step;
            s.spd += (s.bspd * 0.5 - s.spd) * 0.1;
          } else {
            s.segDist += s.spd;
            s.spd += (s.bspd - s.spd) * 0.05;
            if (s.segDist >= s.segLen) {
              s.segDist = 0;
              s.segLen = 30 + snoise(s.seed + 300, tN3 * 0.05) * 50;
              s.turning = turnAngle + (snoise(s.seed + 400, tN3 * 0.1) - 0.5) * 0.5;
              if (snoise(s.seed + 500, tN3 * 0.03) > 0.7) s.turnDir *= -1;
            }
          }
        }

        s.x += Math.cos(s.angle) * s.spd;
        s.y += Math.sin(s.angle) * s.spd;
        // Edge steering
        var ex = Math.abs(s.x - N3W / 2) / (N3W / 2);
        var ey = Math.abs(s.y - N3H / 2) / (N3H / 2);
        var edge = Math.max(ex, ey);
        if (s.shape === 'circle') {
          // Soft centering: continuous quadratic pull, no hard threshold
          var da = Math.atan2(N3H / 2 - s.y, N3W / 2 - s.x) - s.angle;
          while (da > Math.PI) da -= Math.PI * 2;
          while (da < -Math.PI) da += Math.PI * 2;
          s.angle += da * edge * edge * 0.06;
          s.curv *= (1 - edge * edge * 0.15);
        } else if (edge > 0.8) {
          var da = Math.atan2(N3H / 2 - s.y, N3W / 2 - s.x) - s.angle;
          while (da > Math.PI) da -= Math.PI * 2;
          while (da < -Math.PI) da += Math.PI * 2;
          s.angle += da * (edge - 0.8) * 0.4;
          s.turning = 0; s.segDist = 0; s.segLen = 30 + Math.random() * 40;
        }

        // Wake triangle trail
        var tls = [{ hw: 4, a: 0.03 }, { hw: 2, a: 0.08 }, { hw: 0.8, a: 0.18 }];
        for (var li = 0; li < tls.length; li++) {
          ctxN3.fillStyle = 'rgba(' + s.col + ',' + (tls[li].a * pulse3) + ')';
          n3Wake(s.px, s.py, s.x, s.y, tls[li].hw, s.angle);
          ctxN3.fill();
        }
        // Shape head glow
        var gs = [{ r: 6, a: 0.06 * pulse3 }, { r: 3, a: 0.15 * pulse3 }, { r: 1.5, a: 0.4 * pulse3 }];
        for (var gi = 0; gi < gs.length; gi++) {
          ctxN3.fillStyle = 'rgba(' + s.col + ',' + gs[gi].a + ')';
          n3DrawShape(ctxN3, s.shape, s.x, s.y, gs[gi].r, s.angle);
          ctxN3.fill();
        }
        ctxN3.fillStyle = 'rgba(255,240,255,' + (0.7 * pulse3) + ')';
        n3DrawShape(ctxN3, s.shape, s.x, s.y, 1.0, s.angle);
        ctxN3.fill();
      }
      ctxN3.globalCompositeOperation = 'source-over';
      tN3 += 0.008;
    }
    drawNeon3();
  })();

    // --- Neon4 プレビュー（5スケーター + 90°ターン + 衝突色変化）---
    (function() {
    var cn4 = document.getElementById('cvNeon4');
    if (!cn4) return;
    var ctx4 = cn4.getContext('2d');
    var N4W = cn4.width = 400, N4H = cn4.height = 225;
    var tN4 = 0;
    var N4_TURN_SPD = 0.12;

    function n4Wake(tx, ty, hx, hy, hw, ang) {
      var pa = ang + Math.PI / 2;
      var cp = Math.cos(pa), sp = Math.sin(pa);
      ctx4.beginPath();
      ctx4.moveTo(tx, ty);
      ctx4.lineTo(hx + hw * cp, hy + hw * sp);
      ctx4.lineTo(hx - hw * cp, hy - hw * sp);
      ctx4.closePath();
    }
    function n4Sq(cx, cy, r, ang) {
      var c = Math.cos(ang), s = Math.sin(ang), hr = r * 0.707;
      ctx4.beginPath();
      ctx4.moveTo(cx + hr * (c - s), cy + hr * (s + c));
      ctx4.lineTo(cx + hr * (-c - s), cy + hr * (-s + c));
      ctx4.lineTo(cx + hr * (-c + s), cy + hr * (-s - c));
      ctx4.lineTo(cx + hr * (c + s), cy + hr * (s - c));
      ctx4.closePath();
    }

    var n4Colors = [rndNeon(), rndNeon(), rndNeon()];
    var n4S = [];
    for (var i = 0; i < 5; i++) {
      n4S.push({
        x: N4W * (0.1 + i * 0.2), y: N4H * 0.5,
        px: 0, py: 0,
        angle: i * 1.25, spd: 0.8 + i * 0.06, bspd: 0.8 + i * 0.06,
        seed: 42 + i * 95, col: n4Colors[i % 3],
        segDist: 0, segLen: 30 + Math.random() * 40,
        turnDir: Math.random() < 0.5 ? 1 : -1, turning: 0
      });
    }
    for (var i = 0; i < 5; i++) { n4S[i].px = n4S[i].x; n4S[i].py = n4S[i].y; }

    var n4CollCd = {};

    function drawNeon4() {
      requestAnimationFrame(drawNeon4);
      if (!visMap['cvNeon4']) return;
      ctx4.fillStyle = 'rgba(5,0,6,0.08)';
      ctx4.fillRect(0, 0, N4W, N4H);
      var pulse = 0.75 + Math.sin(tN4 * 0.5) * 0.25;
      ctx4.globalCompositeOperation = 'lighter';

      for (var si = 0; si < 5; si++) {
        var s = n4S[si];
        s.px = s.x; s.py = s.y;
        // Square trajectory: wobble + straight/turn
        var wb = (snoise(s.seed, tN4 * 0.08) - 0.5) * 0.012;
        s.angle += wb;
        if (s.turning > 0) {
          var step = Math.min(N4_TURN_SPD, s.turning);
          s.angle += step * s.turnDir;
          s.turning -= step;
          s.spd += (s.bspd * 0.5 - s.spd) * 0.1;
        } else {
          s.segDist += s.spd;
          s.spd += (s.bspd - s.spd) * 0.05;
          if (s.segDist >= s.segLen) {
            s.segDist = 0;
            s.segLen = 30 + snoise(s.seed + 300, tN4 * 0.05) * 50;
            s.turning = Math.PI / 2 + (snoise(s.seed + 400, tN4 * 0.1) - 0.5) * 0.5;
            if (snoise(s.seed + 500, tN4 * 0.03) > 0.7) s.turnDir *= -1;
          }
        }
        s.x += Math.cos(s.angle) * s.spd;
        s.y += Math.sin(s.angle) * s.spd;
        // Edge steering
        var ex = Math.abs(s.x - N4W / 2) / (N4W / 2);
        var ey = Math.abs(s.y - N4H / 2) / (N4H / 2);
        var edge = Math.max(ex, ey);
        if (edge > 0.8) {
          var da = Math.atan2(N4H / 2 - s.y, N4W / 2 - s.x) - s.angle;
          while (da > Math.PI) da -= Math.PI * 2;
          while (da < -Math.PI) da += Math.PI * 2;
          s.angle += da * (edge - 0.8) * 0.4;
          s.turning = 0; s.segDist = 0; s.segLen = 30 + Math.random() * 40;
        }
        // Wake trail
        var tls = [{ hw: 4, a: 0.03 }, { hw: 2, a: 0.08 }, { hw: 0.8, a: 0.18 }];
        for (var li = 0; li < tls.length; li++) {
          ctx4.fillStyle = 'rgba(' + s.col + ',' + (tls[li].a * pulse) + ')';
          n4Wake(s.px, s.py, s.x, s.y, tls[li].hw, s.angle);
          ctx4.fill();
        }
        // Square head glow
        var gs = [{ r: 6, a: 0.06 * pulse }, { r: 3, a: 0.15 * pulse }, { r: 1.5, a: 0.4 * pulse }];
        for (var gi = 0; gi < gs.length; gi++) {
          ctx4.fillStyle = 'rgba(' + s.col + ',' + gs[gi].a + ')';
          n4Sq(s.x, s.y, gs[gi].r, s.angle);
          ctx4.fill();
        }
        ctx4.fillStyle = 'rgba(255,240,255,' + (0.7 * pulse) + ')';
        n4Sq(s.x, s.y, 1.0, s.angle);
        ctx4.fill();
      }

      // Collision + color change
      var nFrame4 = Math.floor(tN4 * 125);
      for (var i = 0; i < 5; i++) {
        for (var j = i + 1; j < 5; j++) {
          var dx = n4S[j].x - n4S[i].x, dy = n4S[j].y - n4S[i].y;
          var d = Math.sqrt(dx * dx + dy * dy);
          var ck = i * 10 + j;
          if (d < 15 && (!n4CollCd[ck] || nFrame4 - n4CollCd[ck] > 100)) {
            n4CollCd[ck] = nFrame4;
            n4S[i].angle = Math.atan2(-dy, -dx) + (Math.random() - 0.5) * 0.8;
            n4S[j].angle = Math.atan2(dy, dx) + (Math.random() - 0.5) * 0.8;
            n4S[i].col = rndNeon();
            n4S[j].col = rndNeon();
            n4S[i].turning = 0; n4S[i].segDist = 0;
            n4S[j].turning = 0; n4S[j].segDist = 0;
          }
        }
      }
      ctx4.globalCompositeOperation = 'source-over';
      tN4 += 0.008;
    }
    drawNeon4();
  })();

    // --- Neon5 プレビュー（3スケーター + Sin/Cos/Sin2波形 + 衝突波形シャッフル）---
    (function() {
    var cn5 = document.getElementById('cvNeon5');
    if (!cn5) return;
    var ctx5 = cn5.getContext('2d');
    var N5W = cn5.width = 400, N5H = cn5.height = 225;
    var tN5 = 0;
    var N5_FREQ = 0.015;
    var N5_AMP = 100;

    function n5Wake(tx, ty, hx, hy, hw, ang) {
      var pa = ang + Math.PI / 2;
      var cp = Math.cos(pa), sp = Math.sin(pa);
      ctx5.beginPath();
      ctx5.moveTo(tx, ty);
      ctx5.lineTo(hx + hw * cp, hy + hw * sp);
      ctx5.lineTo(hx - hw * cp, hy - hw * sp);
      ctx5.closePath();
    }

    function n5WaveFunc(type, phase) {
      if (type === 'sin') return Math.sin(phase);
      if (type === 'cos') return Math.cos(phase);
      return Math.sin(phase * 2);
    }

    var n5Colors = ['255,40,80', '20,100,255', '255,240,180'];
    var n5Types = ['sin', 'cos', 'sin2'];
    var n5S = [];
    for (var i = 0; i < 3; i++) {
      var ba = Math.random() * Math.PI * 2;
      n5S.push({
        x: N5W * (0.2 + i * 0.3), y: N5H * 0.5,
        px: 0, py: 0, ppx: 0, ppy: 0,
        baseX: N5W * (0.2 + i * 0.3), baseY: N5H * 0.5,
        baseAngle: ba, phase: Math.random() * Math.PI * 2,
        angle: ba, spd: 0.8 + i * 0.08, bspd: 0.8 + i * 0.08,
        seed: 42 + i * 95, col: n5Colors[i], waveType: n5Types[i]
      });
    }
    for (var i = 0; i < 3; i++) { n5S[i].px = n5S[i].x; n5S[i].py = n5S[i].y; n5S[i].ppx = n5S[i].x; n5S[i].ppy = n5S[i].y; }

    var n5CollCd = {};

    function drawNeon5() {
      requestAnimationFrame(drawNeon5);
      if (!visMap['cvNeon5']) return;
      ctx5.fillStyle = 'rgba(5,0,6,0.08)';
      ctx5.fillRect(0, 0, N5W, N5H);
      var pulse = 0.75 + Math.sin(tN5 * 0.5) * 0.25;
      ctx5.globalCompositeOperation = 'lighter';

      for (var si = 0; si < 3; si++) {
        var s = n5S[si];
        s.ppx = s.px; s.ppy = s.py;
        s.px = s.x; s.py = s.y;
        // Base angle drift
        s.baseAngle += (snoise(s.seed, tN5 * 0.03) - 0.5) * 0.008;
        s.spd += (s.bspd - s.spd) * 0.03;
        // Advance
        s.phase += s.spd * N5_FREQ;
        s.baseX += Math.cos(s.baseAngle) * s.spd;
        s.baseY += Math.sin(s.baseAngle) * s.spd;
        // Lateral offset
        var perp = s.baseAngle + Math.PI / 2;
        var lat = N5_AMP * n5WaveFunc(s.waveType, s.phase);
        s.x = s.baseX + Math.cos(perp) * lat;
        s.y = s.baseY + Math.sin(perp) * lat;
        // Screen wrap
        var mg = 105, wp = false;
        if (s.baseX < -mg) { var sh = N5W + 2 * mg; s.baseX += sh; s.x += sh; wp = true; }
        else if (s.baseX > N5W + mg) { var sh = N5W + 2 * mg; s.baseX -= sh; s.x -= sh; wp = true; }
        if (s.baseY < -mg) { var sh = N5H + 2 * mg; s.baseY += sh; s.y += sh; wp = true; }
        else if (s.baseY > N5H + mg) { var sh = N5H + 2 * mg; s.baseY -= sh; s.y -= sh; wp = true; }
        if (wp) { s.px = s.x; s.py = s.y; s.ppx = s.x; s.ppy = s.y; }
        // Movement angle
        var mdx = s.x - s.px, mdy = s.y - s.py;
        if (mdx !== 0 || mdy !== 0) s.angle = Math.atan2(mdy, mdx);
        // Wake trail (bezier curves — no joints)
        ctx5.lineCap = 'butt';
        var tls = [{ hw: 4, a: 0.03 }, { hw: 2, a: 0.08 }, { hw: 0.8, a: 0.18 }];
        var m0x = (s.ppx + s.px) * 0.5, m0y = (s.ppy + s.py) * 0.5;
        var m1x = (s.px + s.x) * 0.5, m1y = (s.py + s.y) * 0.5;
        for (var li = 0; li < tls.length; li++) {
          ctx5.strokeStyle = 'rgba(' + s.col + ',' + (tls[li].a * pulse) + ')';
          ctx5.lineWidth = tls[li].hw * 2;
          ctx5.beginPath(); ctx5.moveTo(m0x, m0y); ctx5.quadraticCurveTo(s.px, s.py, m1x, m1y); ctx5.stroke();
        }
        // Circle head glow
        var gs = [{ r: 6, a: 0.06 * pulse }, { r: 3, a: 0.15 * pulse }, { r: 1.5, a: 0.4 * pulse }];
        for (var gi = 0; gi < gs.length; gi++) {
          ctx5.fillStyle = 'rgba(' + s.col + ',' + gs[gi].a + ')';
          ctx5.beginPath(); ctx5.arc(s.x, s.y, gs[gi].r, 0, Math.PI * 2); ctx5.fill();
        }
        ctx5.fillStyle = 'rgba(255,240,255,' + (0.7 * pulse) + ')';
        ctx5.beginPath(); ctx5.arc(s.x, s.y, 1.0, 0, Math.PI * 2); ctx5.fill();
      }

      // Collision + wave shuffle
      var nFrame5 = Math.floor(tN5 * 125);
      for (var i = 0; i < 3; i++) {
        for (var j = i + 1; j < 3; j++) {
          var dx = n5S[j].x - n5S[i].x, dy = n5S[j].y - n5S[i].y;
          var d = Math.sqrt(dx * dx + dy * dy);
          var ck = i * 10 + j;
          if (d < 15 && (!n5CollCd[ck] || nFrame5 - n5CollCd[ck] > 100)) {
            n5CollCd[ck] = nFrame5;
            n5S[i].baseAngle = Math.atan2(-dy, -dx) + (Math.random() - 0.5) * 0.8;
            n5S[j].baseAngle = Math.atan2(dy, dx) + (Math.random() - 0.5) * 0.8;
            n5S[i].spd = 2.5; n5S[j].spd = 2.5;
            // Color change
            n5S[i].col = rndNeon();
            n5S[j].col = rndNeon();
          }
        }
      }
      ctx5.globalCompositeOperation = 'source-over';
      tN5 += 0.008;
    }
    drawNeon5();
  })();

    // --- Neon6 プレビュー（3スケーター + ケプラー軌道）---
    (function() {
    var cn6 = document.getElementById('cvNeon6');
    if (!cn6) return;
    var ctx6 = cn6.getContext('2d');
    var N6W = cn6.width = 400, N6H = cn6.height = 225;
    var tN6 = 0;

    var N6_PRESETS = {
      circular:   { a: 0.55, e: 0.05, period: 900 },
      elliptical: { a: 0.40, e: 0.50, period: 700 },
      comet:      { a: 0.60, e: 0.80, period: 1100 }
    };

    function n6Kepler(M, e) {
      var E = M;
      for (var i = 0; i < 10; i++) {
        var dE = (E - e * Math.sin(E) - M) / (1 - e * Math.cos(E));
        E -= dE;
        if (Math.abs(dE) < 1e-8) break;
      }
      return E;
    }

    function n6OrbitPos(s) {
      var preset = N6_PRESETS[s.oType];
      var scale = Math.min(N6W, N6H) * 0.5;
      var a = preset.a * scale;
      var e = preset.e;
      var b = a * Math.sqrt(1 - e * e);
      var M = (s.phase + s.orbitTime * Math.PI * 2 / preset.period) % (Math.PI * 2);
      var E = n6Kepler(M, e);
      var ox = a * (Math.cos(E) - e);
      var oy = b * Math.sin(E);
      var ct = Math.cos(s.tilt), st = Math.sin(s.tilt);
      return {
        x: N6W * 0.5 + (ox * ct - oy * st),
        y: N6H * 0.5 + (ox * st + oy * ct)
      };
    }

    var n6Colors = ['255,40,80', '20,100,255', '255,240,180'];
    var n6Types = ['circular', 'elliptical', 'comet'];
    var n6S = [];
    var tilts6 = [0, Math.PI * 2 * 0.33, Math.PI * 2 * 0.67];
    for (var i = 0; i < 3; i++) {
      var phase = Math.random() * Math.PI * 2;
      var tilt = tilts6[i] + (Math.random() - 0.5) * 0.6;
      var s = {
        oType: n6Types[i], phase: phase, tilt: tilt,
        orbitTime: 0, precession: (Math.random() - 0.5) * 0.0006,
        x: 0, y: 0, px: 0, py: 0, ppx: 0, ppy: 0,
        col: n6Colors[i], angle: 0
      };
      var pos = n6OrbitPos(s);
      s.x = pos.x; s.y = pos.y; s.px = pos.x; s.py = pos.y; s.ppx = pos.x; s.ppy = pos.y;
      n6S.push(s);
    }

    var n6CollCd = {};

    function drawNeon6() {
      requestAnimationFrame(drawNeon6);
      if (!visMap['cvNeon6']) return;
      ctx6.fillStyle = 'rgba(5,0,6,0.06)';
      ctx6.fillRect(0, 0, N6W, N6H);
      var pulse = 0.75 + Math.sin(tN6 * 0.5) * 0.25;
      ctx6.globalCompositeOperation = 'lighter';

      for (var si = 0; si < 3; si++) {
        var s = n6S[si];
        s.ppx = s.px; s.ppy = s.py;
        s.px = s.x; s.py = s.y;
        s.orbitTime++;
        s.tilt += s.precession;
        var pos = n6OrbitPos(s);
        s.x = pos.x; s.y = pos.y;
        var mdx = s.x - s.px, mdy = s.y - s.py;
        if (mdx !== 0 || mdy !== 0) s.angle = Math.atan2(mdy, mdx);

        // Bezier trail
        ctx6.lineCap = 'butt';
        var m0x = (s.ppx + s.px) * 0.5, m0y = (s.ppy + s.py) * 0.5;
        var m1x = (s.px + s.x) * 0.5, m1y = (s.py + s.y) * 0.5;
        var tls = [{ hw: 4, a: 0.03 }, { hw: 2, a: 0.08 }, { hw: 0.8, a: 0.18 }];
        for (var li = 0; li < tls.length; li++) {
          ctx6.strokeStyle = 'rgba(' + s.col + ',' + (tls[li].a * pulse) + ')';
          ctx6.lineWidth = tls[li].hw * 2;
          ctx6.beginPath(); ctx6.moveTo(m0x, m0y); ctx6.quadraticCurveTo(s.px, s.py, m1x, m1y); ctx6.stroke();
        }

        // Head glow
        var gs = [{ r: 6, a: 0.06 * pulse }, { r: 3, a: 0.15 * pulse }, { r: 1.5, a: 0.4 * pulse }];
        for (var gi = 0; gi < gs.length; gi++) {
          ctx6.fillStyle = 'rgba(' + s.col + ',' + gs[gi].a + ')';
          ctx6.beginPath(); ctx6.arc(s.x, s.y, gs[gi].r, 0, Math.PI * 2); ctx6.fill();
        }
        ctx6.fillStyle = 'rgba(255,240,255,' + (0.7 * pulse) + ')';
        ctx6.beginPath(); ctx6.arc(s.x, s.y, 1.0, 0, Math.PI * 2); ctx6.fill();
      }

      // Collision + orbit swap
      var nFrame6 = Math.floor(tN6 * 125);
      for (var i = 0; i < 3; i++) {
        for (var j = i + 1; j < 3; j++) {
          var dx = n6S[j].x - n6S[i].x, dy = n6S[j].y - n6S[i].y;
          var d = Math.sqrt(dx * dx + dy * dy);
          var ck = i * 10 + j;
          if (d < 15 && (!n6CollCd[ck] || nFrame6 - n6CollCd[ck] > 100)) {
            n6CollCd[ck] = nFrame6;
            var tmp = n6S[i].oType;
            n6S[i].oType = n6S[j].oType;
            n6S[j].oType = tmp;
            n6S[i].tilt += (Math.random() - 0.5);
            n6S[j].tilt += (Math.random() - 0.5);
            n6S[i].col = rndNeon();
            n6S[j].col = rndNeon();
          }
        }
      }
      ctx6.globalCompositeOperation = 'source-over';
      tN6 += 0.008;
    }
    drawNeon6();
  })();

  })();
  }, 10); // end setTimeout — defer canvas init to let loading screen paint
  </script>
</body>
</html>
